diff --git a/node_modules/react-native/Libraries/Animated/nodes/AnimatedProps.js b/node_modules/react-native/Libraries/Animated/nodes/AnimatedProps.js
index 750569f..d458d7a 100644
--- a/node_modules/react-native/Libraries/Animated/nodes/AnimatedProps.js
+++ b/node_modules/react-native/Libraries/Animated/nodes/AnimatedProps.js
@@ -97,6 +97,7 @@ export default class AnimatedProps extends AnimatedNode {
   #nodes: $ReadOnlyArray<AnimatedNode>;
   #props: {[string]: mixed};
   #target: ?TargetView = null;
+  #connectedToView: boolean;
 
   constructor(
     inputProps: {[string]: mixed},
@@ -110,6 +111,7 @@ export default class AnimatedProps extends AnimatedNode {
     this.#nodes = nodes;
     this.#props = props;
     this.#callback = callback;
+    this.#connectedToView = false;
   }
 
   __getValue(): Object {
@@ -248,6 +250,8 @@ export default class AnimatedProps extends AnimatedNode {
 
       if (this.#target != null) {
         this.#connectAnimatedView(this.#target);
+      } else if (!this.#connectedToView && this._animatedView) {
+        this.#connectAnimatedView(this.#target);
       }
     }
   }
@@ -272,6 +276,7 @@ export default class AnimatedProps extends AnimatedNode {
         throw new Error('Unable to locate attached view in the native tree');
       }
     }
+    this.#connectedToView = true;
     NativeAnimatedHelper.API.connectAnimatedNodeToView(
       this.__getNativeTag(),
       viewTag,
@@ -285,6 +290,7 @@ export default class AnimatedProps extends AnimatedNode {
     if (viewTag == null) {
       return;
     }
+    this.#connectedToView = false;
     NativeAnimatedHelper.API.disconnectAnimatedNodeFromView(
       this.__getNativeTag(),
       viewTag,
diff --git a/node_modules/react-native/Libraries/Components/StatusBar/StatusBar.js b/node_modules/react-native/Libraries/Components/StatusBar/StatusBar.js
index 5c266b1..ee75874 100644
--- a/node_modules/react-native/Libraries/Components/StatusBar/StatusBar.js
+++ b/node_modules/react-native/Libraries/Components/StatusBar/StatusBar.js
@@ -492,8 +492,7 @@ class StatusBar extends React.Component<StatusBarProps> {
         }
         // Activities are not translucent by default, so always set if true.
         if (
-          !oldProps ||
-          oldProps.translucent !== mergedProps.translucent ||
+          (oldProps && oldProps.translucent !== mergedProps.translucent) ||
           mergedProps.translucent
         ) {
           NativeStatusBarManagerAndroid.setTranslucent(mergedProps.translucent);
diff --git a/node_modules/react-native/Libraries/Components/StatusBar/StatusBar.js.orig b/node_modules/react-native/Libraries/Components/StatusBar/StatusBar.js.orig
new file mode 100644
index 0000000..5c266b1
--- /dev/null
+++ b/node_modules/react-native/Libraries/Components/StatusBar/StatusBar.js.orig
@@ -0,0 +1,512 @@
+/**
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ *
+ * @flow
+ * @format
+ */
+
+import type {ColorValue} from '../../StyleSheet/StyleSheet';
+
+import processColor from '../../StyleSheet/processColor';
+import Platform from '../../Utilities/Platform';
+import NativeStatusBarManagerAndroid from './NativeStatusBarManagerAndroid';
+import NativeStatusBarManagerIOS from './NativeStatusBarManagerIOS';
+import invariant from 'invariant';
+import * as React from 'react';
+
+/**
+ * Status bar style
+ */
+export type StatusBarStyle = $Keys<{
+  /**
+   * Default status bar style (dark for iOS, light for Android)
+   */
+  default: string,
+  /**
+   * Dark background, white texts and icons
+   */
+  'light-content': string,
+  /**
+   * Light background, dark texts and icons
+   */
+  'dark-content': string,
+  ...
+}>;
+
+/**
+ * Status bar animation
+ */
+export type StatusBarAnimation = $Keys<{
+  /**
+   * No animation
+   */
+  none: string,
+  /**
+   * Fade animation
+   */
+  fade: string,
+  /**
+   * Slide animation
+   */
+  slide: string,
+  ...
+}>;
+
+export type StatusBarPropsAndroid = $ReadOnly<{
+  /**
+   * The background color of the status bar.
+   *
+   * Please note that this prop has no effect on Android 15+
+   *
+   * @platform android
+   */
+  backgroundColor?: ?ColorValue,
+  /**
+   * If the status bar is translucent.
+   * When translucent is set to true, the app will draw under the status bar.
+   * This is useful when using a semi transparent status bar color.
+   *
+   * Please note that this prop has no effect on Android 15+
+   *
+   * @platform android
+   */
+  translucent?: ?boolean,
+}>;
+
+export type StatusBarPropsIOS = $ReadOnly<{
+  /**
+   * If the network activity indicator should be visible.
+   *
+   * @platform ios
+   */
+  networkActivityIndicatorVisible?: ?boolean,
+  /**
+   * The transition effect when showing and hiding the status bar using the `hidden`
+   * prop. Defaults to 'fade'.
+   *
+   * @platform ios
+   */
+  showHideTransition?: ?('fade' | 'slide' | 'none'),
+}>;
+
+type StatusBarBaseProps = $ReadOnly<{
+  /**
+   * If the status bar is hidden.
+   */
+  hidden?: ?boolean,
+  /**
+   * If the transition between status bar property changes should be animated.
+   * Supported for backgroundColor, barStyle and hidden.
+   */
+  animated?: ?boolean,
+  /**
+   * Sets the color of the status bar text.
+   */
+  barStyle?: ?('default' | 'light-content' | 'dark-content'),
+}>;
+
+export type StatusBarProps = $ReadOnly<{
+  ...StatusBarPropsAndroid,
+  ...StatusBarPropsIOS,
+  ...StatusBarBaseProps,
+}>;
+
+type StackProps = {
+  backgroundColor: ?{
+    value: StatusBarProps['backgroundColor'],
+    animated: boolean,
+  },
+  barStyle: ?{
+    value: StatusBarProps['barStyle'],
+    animated: boolean,
+  },
+  translucent: StatusBarProps['translucent'],
+  hidden: ?{
+    value: boolean,
+    animated: boolean,
+    transition: StatusBarProps['showHideTransition'],
+  },
+  networkActivityIndicatorVisible: StatusBarProps['networkActivityIndicatorVisible'],
+};
+
+/**
+ * Merges the prop stack with the default values.
+ */
+function mergePropsStack(
+  propsStack: Array<Object>,
+  defaultValues: Object,
+): Object {
+  return propsStack.reduce(
+    (prev, cur) => {
+      for (const prop in cur) {
+        if (cur[prop] != null) {
+          prev[prop] = cur[prop];
+        }
+      }
+      return prev;
+    },
+    {...defaultValues},
+  );
+}
+
+/**
+ * Returns an object to insert in the props stack from the props
+ * and the transition/animation info.
+ */
+function createStackEntry(props: StatusBarProps): StackProps {
+  const animated = props.animated ?? false;
+  const showHideTransition = props.showHideTransition ?? 'fade';
+  return {
+    backgroundColor:
+      props.backgroundColor != null
+        ? {
+            value: props.backgroundColor,
+            animated,
+          }
+        : null,
+    barStyle:
+      props.barStyle != null
+        ? {
+            value: props.barStyle,
+            animated,
+          }
+        : null,
+    translucent: props.translucent,
+    hidden:
+      props.hidden != null
+        ? {
+            value: props.hidden,
+            animated,
+            transition: showHideTransition,
+          }
+        : null,
+    networkActivityIndicatorVisible: props.networkActivityIndicatorVisible,
+  };
+}
+
+/**
+ * Component to control the app status bar.
+ *
+ * It is possible to have multiple `StatusBar` components mounted at the same
+ * time. The props will be merged in the order the `StatusBar` components were
+ * mounted.
+ *
+ * ### Imperative API
+ *
+ * For cases where using a component is not ideal, there are static methods
+ * to manipulate the `StatusBar` display stack. These methods have the same
+ * behavior as mounting and unmounting a `StatusBar` component.
+ *
+ * For example, you can call `StatusBar.pushStackEntry` to update the status bar
+ * before launching a third-party native UI component, and then call
+ * `StatusBar.popStackEntry` when completed.
+ *
+ * ```
+ * const openThirdPartyBugReporter = async () => {
+ *   // The bug reporter has a dark background, so we push a new status bar style.
+ *   const stackEntry = StatusBar.pushStackEntry({barStyle: 'light-content'});
+ *
+ *   // `open` returns a promise that resolves when the UI is dismissed.
+ *   await BugReporter.open();
+ *
+ *   // Don't forget to call `popStackEntry` when you're done.
+ *   StatusBar.popStackEntry(stackEntry);
+ * };
+ * ```
+ *
+ * There is a legacy imperative API that enables you to manually update the
+ * status bar styles. However, the legacy API does not update the internal
+ * `StatusBar` display stack, which means that any changes will be overridden
+ * whenever a `StatusBar` component is mounted or unmounted.
+ *
+ * It is strongly advised that you use `pushStackEntry`, `popStackEntry`, or
+ * `replaceStackEntry` instead of the static methods beginning with `set`.
+ *
+ * ### Constants
+ *
+ * `currentHeight` (Android only) The height of the status bar.
+ */
+class StatusBar extends React.Component<StatusBarProps> {
+  static _propsStack: Array<StackProps> = [];
+
+  static _defaultProps: any = createStackEntry({
+    backgroundColor:
+      Platform.OS === 'android'
+        ? NativeStatusBarManagerAndroid.getConstants()
+            .DEFAULT_BACKGROUND_COLOR ?? 'black'
+        : 'black',
+    barStyle: 'default',
+    translucent: false,
+    hidden: false,
+    networkActivityIndicatorVisible: false,
+  });
+
+  // Timer for updating the native module values at the end of the frame.
+  static _updateImmediate: ?number = null;
+
+  // The current merged values from the props stack.
+  static _currentValues: ?StackProps = null;
+
+  // TODO(janic): Provide a real API to deal with status bar height. See the
+  // discussion in #6195.
+  /**
+   * The current height of the status bar on the device.
+   *
+   * @platform android
+   */
+  static currentHeight: ?number =
+    Platform.OS === 'android'
+      ? NativeStatusBarManagerAndroid.getConstants().HEIGHT
+      : null;
+
+  // Provide an imperative API as static functions of the component.
+  // See the corresponding prop for more detail.
+
+  /**
+   * Show or hide the status bar
+   * @param hidden Hide the status bar.
+   * @param animation Optional animation when
+   *    changing the status bar hidden property.
+   */
+  static setHidden(hidden: boolean, animation?: StatusBarAnimation) {
+    animation = animation || 'none';
+    StatusBar._defaultProps.hidden.value = hidden;
+    if (Platform.OS === 'ios') {
+      NativeStatusBarManagerIOS.setHidden(hidden, animation);
+    } else if (Platform.OS === 'android') {
+      NativeStatusBarManagerAndroid.setHidden(hidden);
+    }
+  }
+
+  /**
+   * Set the status bar style
+   * @param style Status bar style to set
+   * @param animated Animate the style change.
+   */
+  static setBarStyle(style: StatusBarStyle, animated?: boolean) {
+    animated = animated || false;
+    StatusBar._defaultProps.barStyle.value = style;
+    if (Platform.OS === 'ios') {
+      NativeStatusBarManagerIOS.setStyle(style, animated);
+    } else if (Platform.OS === 'android') {
+      NativeStatusBarManagerAndroid.setStyle(style);
+    }
+  }
+
+  /**
+   * DEPRECATED - The status bar network activity indicator is not supported in iOS 13 and later. This will be removed in a future release.
+   * @param visible Show the indicator.
+   *
+   * @deprecated
+   */
+  static setNetworkActivityIndicatorVisible(visible: boolean) {
+    if (Platform.OS !== 'ios') {
+      console.warn(
+        '`setNetworkActivityIndicatorVisible` is only available on iOS',
+      );
+      return;
+    }
+    StatusBar._defaultProps.networkActivityIndicatorVisible = visible;
+    NativeStatusBarManagerIOS.setNetworkActivityIndicatorVisible(visible);
+  }
+
+  /**
+   * Set the background color for the status bar
+   * @param color Background color.
+   * @param animated Animate the style change.
+   */
+  static setBackgroundColor(color: ColorValue, animated?: boolean): void {
+    if (Platform.OS !== 'android') {
+      console.warn('`setBackgroundColor` is only available on Android');
+      return;
+    }
+    animated = animated || false;
+    StatusBar._defaultProps.backgroundColor.value = color;
+
+    const processedColor = processColor(color);
+    if (processedColor == null) {
+      console.warn(
+        `\`StatusBar.setBackgroundColor\`: Color ${String(color)} parsed to null or undefined`,
+      );
+      return;
+    }
+    invariant(
+      typeof processedColor === 'number',
+      'Unexpected color given for StatusBar.setBackgroundColor',
+    );
+
+    NativeStatusBarManagerAndroid.setColor(processedColor, animated);
+  }
+
+  /**
+   * Control the translucency of the status bar
+   * @param translucent Set as translucent.
+   */
+  static setTranslucent(translucent: boolean) {
+    if (Platform.OS !== 'android') {
+      console.warn('`setTranslucent` is only available on Android');
+      return;
+    }
+    StatusBar._defaultProps.translucent = translucent;
+    NativeStatusBarManagerAndroid.setTranslucent(translucent);
+  }
+
+  /**
+   * Push a StatusBar entry onto the stack.
+   * The return value should be passed to `popStackEntry` when complete.
+   *
+   * @param props Object containing the StatusBar props to use in the stack entry.
+   */
+  static pushStackEntry(props: StatusBarProps): StackProps {
+    const entry = createStackEntry(props);
+    StatusBar._propsStack.push(entry);
+    StatusBar._updatePropsStack();
+    return entry;
+  }
+
+  /**
+   * Pop a StatusBar entry from the stack.
+   *
+   * @param entry Entry returned from `pushStackEntry`.
+   */
+  static popStackEntry(entry: StackProps) {
+    const index = StatusBar._propsStack.indexOf(entry);
+    if (index !== -1) {
+      StatusBar._propsStack.splice(index, 1);
+    }
+    StatusBar._updatePropsStack();
+  }
+
+  /**
+   * Replace an existing StatusBar stack entry with new props.
+   *
+   * @param entry Entry returned from `pushStackEntry` to replace.
+   * @param props Object containing the StatusBar props to use in the replacement stack entry.
+   */
+  static replaceStackEntry(
+    entry: StackProps,
+    props: StatusBarProps,
+  ): StackProps {
+    const newEntry = createStackEntry(props);
+    const index = StatusBar._propsStack.indexOf(entry);
+    if (index !== -1) {
+      StatusBar._propsStack[index] = newEntry;
+    }
+    StatusBar._updatePropsStack();
+    return newEntry;
+  }
+
+  _stackEntry: ?StackProps = null;
+
+  componentDidMount() {
+    // Every time a StatusBar component is mounted, we push it's prop to a stack
+    // and always update the native status bar with the props from the top of then
+    // stack. This allows having multiple StatusBar components and the one that is
+    // added last or is deeper in the view hierarchy will have priority.
+    this._stackEntry = StatusBar.pushStackEntry(this.props);
+  }
+
+  componentWillUnmount() {
+    // When a StatusBar is unmounted, remove itself from the stack and update
+    // the native bar with the next props.
+    if (this._stackEntry != null) {
+      StatusBar.popStackEntry(this._stackEntry);
+    }
+  }
+
+  componentDidUpdate() {
+    if (this._stackEntry != null) {
+      this._stackEntry = StatusBar.replaceStackEntry(
+        this._stackEntry,
+        this.props,
+      );
+    }
+  }
+
+  /**
+   * Updates the native status bar with the props from the stack.
+   */
+  static _updatePropsStack = () => {
+    // Send the update to the native module only once at the end of the frame.
+    clearImmediate(StatusBar._updateImmediate);
+    StatusBar._updateImmediate = setImmediate(() => {
+      const oldProps = StatusBar._currentValues;
+      const mergedProps = mergePropsStack(
+        StatusBar._propsStack,
+        StatusBar._defaultProps,
+      );
+
+      // Update the props that have changed using the merged values from the props stack.
+      if (Platform.OS === 'ios') {
+        if (
+          !oldProps ||
+          oldProps.barStyle?.value !== mergedProps.barStyle.value
+        ) {
+          NativeStatusBarManagerIOS.setStyle(
+            mergedProps.barStyle.value,
+            mergedProps.barStyle.animated || false,
+          );
+        }
+        if (!oldProps || oldProps.hidden?.value !== mergedProps.hidden.value) {
+          NativeStatusBarManagerIOS.setHidden(
+            mergedProps.hidden.value,
+            mergedProps.hidden.animated
+              ? mergedProps.hidden.transition
+              : 'none',
+          );
+        }
+
+        if (
+          !oldProps ||
+          oldProps.networkActivityIndicatorVisible !==
+            mergedProps.networkActivityIndicatorVisible
+        ) {
+          NativeStatusBarManagerIOS.setNetworkActivityIndicatorVisible(
+            mergedProps.networkActivityIndicatorVisible,
+          );
+        }
+      } else if (Platform.OS === 'android') {
+        //todo(T60684787): Add back optimization to only update bar style and
+        //background color if the new value is different from the old value.
+        NativeStatusBarManagerAndroid.setStyle(mergedProps.barStyle.value);
+        const processedColor = processColor(mergedProps.backgroundColor.value);
+        if (processedColor == null) {
+          console.warn(
+            `\`StatusBar._updatePropsStack\`: Color ${mergedProps.backgroundColor.value} parsed to null or undefined`,
+          );
+        } else {
+          invariant(
+            typeof processedColor === 'number',
+            'Unexpected color given in StatusBar._updatePropsStack',
+          );
+          NativeStatusBarManagerAndroid.setColor(
+            processedColor,
+            mergedProps.backgroundColor.animated,
+          );
+        }
+        if (!oldProps || oldProps.hidden?.value !== mergedProps.hidden.value) {
+          NativeStatusBarManagerAndroid.setHidden(mergedProps.hidden.value);
+        }
+        // Activities are not translucent by default, so always set if true.
+        if (
+          !oldProps ||
+          oldProps.translucent !== mergedProps.translucent ||
+          mergedProps.translucent
+        ) {
+          NativeStatusBarManagerAndroid.setTranslucent(mergedProps.translucent);
+        }
+      }
+      // Update the current prop values.
+      StatusBar._currentValues = mergedProps;
+    });
+  };
+
+  render(): React.Node {
+    return null;
+  }
+}
+
+export default StatusBar;
diff --git a/node_modules/react-native/React/Fabric/Mounting/ComponentViews/TextInput/RCTTextInputComponentView.mm b/node_modules/react-native/React/Fabric/Mounting/ComponentViews/TextInput/RCTTextInputComponentView.mm
index 577bebe..cf7032a 100644
--- a/node_modules/react-native/React/Fabric/Mounting/ComponentViews/TextInput/RCTTextInputComponentView.mm
+++ b/node_modules/react-native/React/Fabric/Mounting/ComponentViews/TextInput/RCTTextInputComponentView.mm
@@ -178,6 +178,11 @@ - (NSObject *)accessibilityElement
 
 #pragma mark - RCTComponentViewProtocol
 
++ (BOOL)shouldBeRecycled
+{
+    return NO;
+}
+
 + (ComponentDescriptorProvider)componentDescriptorProvider
 {
   return concreteComponentDescriptorProvider<TextInputComponentDescriptor>();
diff --git a/node_modules/react-native/React/Fabric/Mounting/ComponentViews/TextInput/RCTTextInputComponentView.mm.orig b/node_modules/react-native/React/Fabric/Mounting/ComponentViews/TextInput/RCTTextInputComponentView.mm.orig
new file mode 100644
index 0000000..577bebe
--- /dev/null
+++ b/node_modules/react-native/React/Fabric/Mounting/ComponentViews/TextInput/RCTTextInputComponentView.mm.orig
@@ -0,0 +1,886 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+#import "RCTTextInputComponentView.h"
+
+#import <react/featureflags/ReactNativeFeatureFlags.h>
+#import <react/renderer/components/iostextinput/TextInputComponentDescriptor.h>
+#import <react/renderer/textlayoutmanager/RCTAttributedTextUtils.h>
+#import <react/renderer/textlayoutmanager/TextLayoutManager.h>
+
+#import <React/RCTBackedTextInputViewProtocol.h>
+#import <React/RCTScrollViewComponentView.h>
+#import <React/RCTUITextField.h>
+#import <React/RCTUITextView.h>
+#import <React/RCTUtils.h>
+
+#import "RCTConversions.h"
+#import "RCTTextInputNativeCommands.h"
+#import "RCTTextInputUtils.h"
+
+#import <limits>
+#import "RCTFabricComponentsPlugins.h"
+
+/** Native iOS text field bottom keyboard offset amount */
+static const CGFloat kSingleLineKeyboardBottomOffset = 15.0;
+
+using namespace facebook::react;
+
+@interface RCTTextInputComponentView () <
+    RCTBackedTextInputDelegate,
+    RCTTextInputViewProtocol,
+    UIDropInteractionDelegate>
+@end
+
+static NSSet<NSNumber *> *returnKeyTypesSet;
+
+@implementation RCTTextInputComponentView {
+  TextInputShadowNode::ConcreteState::Shared _state;
+  UIView<RCTBackedTextInputViewProtocol> *_backedTextInputView;
+  NSUInteger _mostRecentEventCount;
+  NSAttributedString *_lastStringStateWasUpdatedWith;
+
+  /*
+   * UIKit uses either UITextField or UITextView as its UIKit element for <TextInput>. UITextField is for single line
+   * entry, UITextView is for multiline entry. There is a problem with order of events when user types a character. In
+   * UITextField (single line text entry), typing a character first triggers `onChange` event and then
+   * onSelectionChange. In UITextView (multi line text entry), typing a character first triggers `onSelectionChange` and
+   * then onChange. JavaScript depends on `onChange` to be called before `onSelectionChange`. This flag keeps state so
+   * if UITextView is backing text input view, inside `-[RCTTextInputComponentView textInputDidChangeSelection]` we make
+   * sure to call `onChange` before `onSelectionChange` and ignore next `-[RCTTextInputComponentView
+   * textInputDidChange]` call.
+   */
+  BOOL _ignoreNextTextInputCall;
+
+  /*
+   * A flag that when set to true, `_mostRecentEventCount` won't be incremented when `[self _updateState]`
+   * and delegate methods `textInputDidChange` and `textInputDidChangeSelection` will exit early.
+   *
+   * Setting `_backedTextInputView.attributedText` triggers delegate methods `textInputDidChange` and
+   * `textInputDidChangeSelection` for multiline text input only.
+   * In multiline text input this is undesirable as we don't want to be sending events for changes that JS triggered.
+   */
+  BOOL _comingFromJS;
+  BOOL _didMoveToWindow;
+
+  /*
+   * Newly initialized default typing attributes contain a no-op NSParagraphStyle and NSShadow. These cause inequality
+   * between the AttributedString backing the input and those generated from state. We store these attributes to make
+   * later comparison insensitive to them.
+   */
+  NSDictionary<NSAttributedStringKey, id> *_originalTypingAttributes;
+
+  BOOL _hasInputAccessoryView;
+  CGSize _previousContentSize;
+}
+
+#pragma mark - UIView overrides
+
+- (instancetype)initWithFrame:(CGRect)frame
+{
+  if (self = [super initWithFrame:frame]) {
+    const auto &defaultProps = TextInputShadowNode::defaultSharedProps();
+    _props = defaultProps;
+
+    _backedTextInputView = defaultProps->multiline ? [RCTUITextView new] : [RCTUITextField new];
+    _backedTextInputView.textInputDelegate = self;
+    _ignoreNextTextInputCall = NO;
+    _comingFromJS = NO;
+    _didMoveToWindow = NO;
+    _originalTypingAttributes = [_backedTextInputView.typingAttributes copy];
+    _previousContentSize = CGSizeZero;
+
+    [self addSubview:_backedTextInputView];
+    [self initializeReturnKeyType];
+  }
+
+  return self;
+}
+
+- (void)updateEventEmitter:(const EventEmitter::Shared &)eventEmitter
+{
+  [super updateEventEmitter:eventEmitter];
+
+  NSMutableDictionary<NSAttributedStringKey, id> *defaultAttributes =
+      [_backedTextInputView.defaultTextAttributes mutableCopy];
+
+  defaultAttributes[RCTAttributedStringEventEmitterKey] = RCTWrapEventEmitter(_eventEmitter);
+
+  _backedTextInputView.defaultTextAttributes = defaultAttributes;
+}
+
+- (void)didMoveToWindow
+{
+  [super didMoveToWindow];
+
+  if (self.window && !_didMoveToWindow) {
+    const auto &props = static_cast<const TextInputProps &>(*_props);
+    if (props.autoFocus) {
+      [_backedTextInputView becomeFirstResponder];
+      [self scrollCursorIntoView];
+    }
+    _didMoveToWindow = YES;
+    [self initializeReturnKeyType];
+  }
+
+  [self _restoreTextSelection];
+}
+
+// TODO: replace with registerForTraitChanges once iOS 17.0 is the lowest supported version
+- (void)traitCollectionDidChange:(UITraitCollection *)previousTraitCollection
+{
+  [super traitCollectionDidChange:previousTraitCollection];
+
+  if (facebook::react::ReactNativeFeatureFlags::enableFontScaleChangesUpdatingLayout() &&
+      UITraitCollection.currentTraitCollection.preferredContentSizeCategory !=
+          previousTraitCollection.preferredContentSizeCategory) {
+    const auto &newTextInputProps = static_cast<const TextInputProps &>(*_props);
+    _backedTextInputView.defaultTextAttributes =
+        RCTNSTextAttributesFromTextAttributes(newTextInputProps.getEffectiveTextAttributes(RCTFontSizeMultiplier()));
+  }
+}
+
+- (void)reactUpdateResponderOffsetForScrollView:(RCTScrollViewComponentView *)scrollView
+{
+  if (![self isDescendantOfView:scrollView.scrollView] || !_backedTextInputView.isFirstResponder) {
+    // View is outside scroll view or it's not a first responder.
+    scrollView.firstResponderViewOutsideScrollView = _backedTextInputView;
+    return;
+  }
+
+  UITextRange *selectedTextRange = _backedTextInputView.selectedTextRange;
+  UITextSelectionRect *selection = [_backedTextInputView selectionRectsForRange:selectedTextRange].firstObject;
+  CGRect focusRect;
+  if (selection == nil) {
+    // No active selection or caret - fallback to entire input frame
+    focusRect = self.bounds;
+  } else {
+    // Focus on text selection frame
+    focusRect = selection.rect;
+    BOOL isMultiline = [_backedTextInputView isKindOfClass:[UITextView class]];
+    if (!isMultiline) {
+      focusRect.size.height += kSingleLineKeyboardBottomOffset;
+    }
+  }
+  scrollView.firstResponderFocus = [self convertRect:focusRect toView:nil];
+}
+
+#pragma mark - RCTViewComponentView overrides
+
+- (NSObject *)accessibilityElement
+{
+  return _backedTextInputView;
+}
+
+#pragma mark - RCTComponentViewProtocol
+
++ (ComponentDescriptorProvider)componentDescriptorProvider
+{
+  return concreteComponentDescriptorProvider<TextInputComponentDescriptor>();
+}
+
+- (void)updateProps:(const Props::Shared &)props oldProps:(const Props::Shared &)oldProps
+{
+  const auto &oldTextInputProps = static_cast<const TextInputProps &>(*_props);
+  const auto &newTextInputProps = static_cast<const TextInputProps &>(*props);
+
+  // Traits:
+  if (newTextInputProps.multiline != oldTextInputProps.multiline) {
+    [self _setMultiline:newTextInputProps.multiline];
+  }
+
+  if (newTextInputProps.traits.autocapitalizationType != oldTextInputProps.traits.autocapitalizationType) {
+    _backedTextInputView.autocapitalizationType =
+        RCTUITextAutocapitalizationTypeFromAutocapitalizationType(newTextInputProps.traits.autocapitalizationType);
+  }
+
+  if (newTextInputProps.traits.autoCorrect != oldTextInputProps.traits.autoCorrect) {
+    _backedTextInputView.autocorrectionType =
+        RCTUITextAutocorrectionTypeFromOptionalBool(newTextInputProps.traits.autoCorrect);
+  }
+
+  if (newTextInputProps.traits.contextMenuHidden != oldTextInputProps.traits.contextMenuHidden) {
+    _backedTextInputView.contextMenuHidden = newTextInputProps.traits.contextMenuHidden;
+  }
+
+  if (newTextInputProps.traits.editable != oldTextInputProps.traits.editable) {
+    _backedTextInputView.editable = newTextInputProps.traits.editable;
+  }
+
+  if (newTextInputProps.multiline &&
+      newTextInputProps.traits.dataDetectorTypes != oldTextInputProps.traits.dataDetectorTypes) {
+    _backedTextInputView.dataDetectorTypes =
+        RCTUITextViewDataDetectorTypesFromStringVector(newTextInputProps.traits.dataDetectorTypes);
+  }
+
+  if (newTextInputProps.traits.enablesReturnKeyAutomatically !=
+      oldTextInputProps.traits.enablesReturnKeyAutomatically) {
+    _backedTextInputView.enablesReturnKeyAutomatically = newTextInputProps.traits.enablesReturnKeyAutomatically;
+  }
+
+  if (newTextInputProps.traits.keyboardAppearance != oldTextInputProps.traits.keyboardAppearance) {
+    _backedTextInputView.keyboardAppearance =
+        RCTUIKeyboardAppearanceFromKeyboardAppearance(newTextInputProps.traits.keyboardAppearance);
+  }
+
+  if (newTextInputProps.traits.spellCheck != oldTextInputProps.traits.spellCheck) {
+    _backedTextInputView.spellCheckingType =
+        RCTUITextSpellCheckingTypeFromOptionalBool(newTextInputProps.traits.spellCheck);
+  }
+
+  if (newTextInputProps.traits.caretHidden != oldTextInputProps.traits.caretHidden) {
+    _backedTextInputView.caretHidden = newTextInputProps.traits.caretHidden;
+  }
+
+  if (newTextInputProps.traits.clearButtonMode != oldTextInputProps.traits.clearButtonMode) {
+    _backedTextInputView.clearButtonMode =
+        RCTUITextFieldViewModeFromTextInputAccessoryVisibilityMode(newTextInputProps.traits.clearButtonMode);
+  }
+
+  if (newTextInputProps.traits.scrollEnabled != oldTextInputProps.traits.scrollEnabled) {
+    _backedTextInputView.scrollEnabled = newTextInputProps.traits.scrollEnabled;
+  }
+
+  if (newTextInputProps.traits.secureTextEntry != oldTextInputProps.traits.secureTextEntry) {
+    _backedTextInputView.secureTextEntry = newTextInputProps.traits.secureTextEntry;
+  }
+
+  if (newTextInputProps.traits.keyboardType != oldTextInputProps.traits.keyboardType) {
+    _backedTextInputView.keyboardType = RCTUIKeyboardTypeFromKeyboardType(newTextInputProps.traits.keyboardType);
+  }
+
+  if (newTextInputProps.traits.returnKeyType != oldTextInputProps.traits.returnKeyType) {
+    _backedTextInputView.returnKeyType = RCTUIReturnKeyTypeFromReturnKeyType(newTextInputProps.traits.returnKeyType);
+  }
+
+  if (newTextInputProps.traits.textContentType != oldTextInputProps.traits.textContentType) {
+    _backedTextInputView.textContentType = RCTUITextContentTypeFromString(newTextInputProps.traits.textContentType);
+  }
+
+  if (newTextInputProps.traits.passwordRules != oldTextInputProps.traits.passwordRules) {
+    _backedTextInputView.passwordRules = RCTUITextInputPasswordRulesFromString(newTextInputProps.traits.passwordRules);
+  }
+
+  if (newTextInputProps.traits.smartInsertDelete != oldTextInputProps.traits.smartInsertDelete) {
+    _backedTextInputView.smartInsertDeleteType =
+        RCTUITextSmartInsertDeleteTypeFromOptionalBool(newTextInputProps.traits.smartInsertDelete);
+  }
+
+  if (newTextInputProps.traits.showSoftInputOnFocus != oldTextInputProps.traits.showSoftInputOnFocus) {
+    [self _setShowSoftInputOnFocus:newTextInputProps.traits.showSoftInputOnFocus];
+  }
+
+  // Traits `blurOnSubmit`, `clearTextOnFocus`, and `selectTextOnFocus` were omitted intentionally here
+  // because they are being checked on-demand.
+
+  // Other props:
+  if (newTextInputProps.placeholder != oldTextInputProps.placeholder) {
+    _backedTextInputView.placeholder = RCTNSStringFromString(newTextInputProps.placeholder);
+  }
+
+  if (newTextInputProps.placeholderTextColor != oldTextInputProps.placeholderTextColor) {
+    _backedTextInputView.placeholderColor = RCTUIColorFromSharedColor(newTextInputProps.placeholderTextColor);
+  }
+
+  if (newTextInputProps.textAttributes != oldTextInputProps.textAttributes) {
+    NSMutableDictionary<NSAttributedStringKey, id> *defaultAttributes =
+        RCTNSTextAttributesFromTextAttributes(newTextInputProps.getEffectiveTextAttributes(RCTFontSizeMultiplier()));
+    defaultAttributes[RCTAttributedStringEventEmitterKey] =
+        _backedTextInputView.defaultTextAttributes[RCTAttributedStringEventEmitterKey];
+    _backedTextInputView.defaultTextAttributes = defaultAttributes;
+  }
+
+  if (newTextInputProps.selectionColor != oldTextInputProps.selectionColor) {
+    _backedTextInputView.tintColor = RCTUIColorFromSharedColor(newTextInputProps.selectionColor);
+  }
+
+  if (newTextInputProps.inputAccessoryViewID != oldTextInputProps.inputAccessoryViewID) {
+    _backedTextInputView.inputAccessoryViewID = RCTNSStringFromString(newTextInputProps.inputAccessoryViewID);
+  }
+
+  if (newTextInputProps.inputAccessoryViewButtonLabel != oldTextInputProps.inputAccessoryViewButtonLabel) {
+    _backedTextInputView.inputAccessoryViewButtonLabel =
+        RCTNSStringFromString(newTextInputProps.inputAccessoryViewButtonLabel);
+  }
+
+  if (newTextInputProps.disableKeyboardShortcuts != oldTextInputProps.disableKeyboardShortcuts) {
+    _backedTextInputView.disableKeyboardShortcuts = newTextInputProps.disableKeyboardShortcuts;
+  }
+
+  if (newTextInputProps.acceptDragAndDropTypes != oldTextInputProps.acceptDragAndDropTypes) {
+    if (!newTextInputProps.acceptDragAndDropTypes.has_value()) {
+      _backedTextInputView.acceptDragAndDropTypes = nil;
+    } else {
+      auto &vector = newTextInputProps.acceptDragAndDropTypes.value();
+      NSMutableArray<NSString *> *array = [NSMutableArray arrayWithCapacity:vector.size()];
+      for (const std::string &str : vector) {
+        [array addObject:[NSString stringWithUTF8String:str.c_str()]];
+      }
+      _backedTextInputView.acceptDragAndDropTypes = array;
+    }
+  }
+
+  [super updateProps:props oldProps:oldProps];
+
+  [self setDefaultInputAccessoryView];
+}
+
+- (void)updateState:(const State::Shared &)state oldState:(const State::Shared &)oldState
+{
+  _state = std::static_pointer_cast<const TextInputShadowNode::ConcreteState>(state);
+
+  if (!_state) {
+    assert(false && "State is `null` for <TextInput> component.");
+    _backedTextInputView.attributedText = nil;
+    return;
+  }
+
+  auto data = _state->getData();
+
+  if (!oldState) {
+    _mostRecentEventCount = _state->getData().mostRecentEventCount;
+  }
+
+  if (_mostRecentEventCount == _state->getData().mostRecentEventCount) {
+    _comingFromJS = YES;
+    [self _setAttributedString:RCTNSAttributedStringFromAttributedStringBox(data.attributedStringBox)];
+    _comingFromJS = NO;
+  }
+}
+
+- (void)updateLayoutMetrics:(const LayoutMetrics &)layoutMetrics
+           oldLayoutMetrics:(const LayoutMetrics &)oldLayoutMetrics
+{
+  [super updateLayoutMetrics:layoutMetrics oldLayoutMetrics:oldLayoutMetrics];
+
+  _backedTextInputView.frame =
+      UIEdgeInsetsInsetRect(self.bounds, RCTUIEdgeInsetsFromEdgeInsets(layoutMetrics.borderWidth));
+  _backedTextInputView.textContainerInset =
+      RCTUIEdgeInsetsFromEdgeInsets(layoutMetrics.contentInsets - layoutMetrics.borderWidth);
+
+  if (!CGSizeEqualToSize(_previousContentSize, _backedTextInputView.contentSize) && _eventEmitter) {
+    _previousContentSize = _backedTextInputView.contentSize;
+    static_cast<const TextInputEventEmitter &>(*_eventEmitter).onContentSizeChange([self _textInputMetrics]);
+  }
+}
+
+- (void)prepareForRecycle
+{
+  [super prepareForRecycle];
+  _state.reset();
+  _backedTextInputView.attributedText = nil;
+  _mostRecentEventCount = 0;
+  _comingFromJS = NO;
+  _lastStringStateWasUpdatedWith = nil;
+  _ignoreNextTextInputCall = NO;
+  _didMoveToWindow = NO;
+  [_backedTextInputView resignFirstResponder];
+}
+
+#pragma mark - RCTBackedTextInputDelegate
+
+- (BOOL)textInputShouldBeginEditing
+{
+  return YES;
+}
+
+- (void)textInputDidBeginEditing
+{
+  if (_eventEmitter) {
+    static_cast<const TextInputEventEmitter &>(*_eventEmitter).onFocus([self _textInputMetrics]);
+  }
+}
+
+- (BOOL)textInputShouldEndEditing
+{
+  return YES;
+}
+
+- (void)textInputDidEndEditing
+{
+  if (_eventEmitter) {
+    static_cast<const TextInputEventEmitter &>(*_eventEmitter).onEndEditing([self _textInputMetrics]);
+    static_cast<const TextInputEventEmitter &>(*_eventEmitter).onBlur([self _textInputMetrics]);
+  }
+}
+
+- (BOOL)textInputShouldSubmitOnReturn
+{
+  const SubmitBehavior submitBehavior = [self getSubmitBehavior];
+  const BOOL shouldSubmit = submitBehavior == SubmitBehavior::Submit || submitBehavior == SubmitBehavior::BlurAndSubmit;
+  // We send `submit` event here, in `textInputShouldSubmitOnReturn`
+  // (not in `textInputDidReturn)`, because of semantic of the event:
+  // `onSubmitEditing` is called when "Submit" button
+  // (the blue key on onscreen keyboard) did pressed
+  // (no connection to any specific "submitting" process).
+
+  if (_eventEmitter && shouldSubmit) {
+    static_cast<const TextInputEventEmitter &>(*_eventEmitter).onSubmitEditing([self _textInputMetrics]);
+  }
+  return shouldSubmit;
+}
+
+- (BOOL)textInputShouldReturn
+{
+  return [self getSubmitBehavior] == SubmitBehavior::BlurAndSubmit;
+}
+
+- (void)textInputDidReturn
+{
+  // Does nothing.
+}
+
+- (NSString *)textInputShouldChangeText:(NSString *)text inRange:(NSRange)range
+{
+  const auto &props = static_cast<const TextInputProps &>(*_props);
+
+  if (!_backedTextInputView.textWasPasted) {
+    if (_eventEmitter) {
+      const auto &textInputEventEmitter = static_cast<const TextInputEventEmitter &>(*_eventEmitter);
+      textInputEventEmitter.onKeyPress({
+          .text = RCTStringFromNSString(text),
+          .eventCount = static_cast<int>(_mostRecentEventCount),
+      });
+    }
+  }
+
+  if (props.maxLength < std::numeric_limits<int>::max()) {
+    NSInteger allowedLength = props.maxLength - _backedTextInputView.attributedText.string.length + range.length;
+
+    if (allowedLength > 0 && text.length > allowedLength) {
+      // make sure unicode characters that are longer than 16 bits (such as emojis) are not cut off
+      NSRange cutOffCharacterRange = [text rangeOfComposedCharacterSequenceAtIndex:allowedLength - 1];
+      if (cutOffCharacterRange.location + cutOffCharacterRange.length > allowedLength) {
+        // the character at the length limit takes more than 16bits, truncation should end at the character before
+        allowedLength = cutOffCharacterRange.location;
+      }
+    }
+
+    if (allowedLength <= 0) {
+      return nil;
+    }
+
+    return allowedLength > text.length ? text : [text substringToIndex:allowedLength];
+  }
+
+  return text;
+}
+
+- (BOOL)textInputShouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text
+{
+  return YES;
+}
+
+- (void)textInputDidChange
+{
+  if (_comingFromJS) {
+    return;
+  }
+
+  if (_ignoreNextTextInputCall && [_lastStringStateWasUpdatedWith isEqual:_backedTextInputView.attributedText]) {
+    _ignoreNextTextInputCall = NO;
+    return;
+  }
+
+  [self _updateState];
+
+  if (_eventEmitter) {
+    const auto &textInputEventEmitter = static_cast<const TextInputEventEmitter &>(*_eventEmitter);
+    textInputEventEmitter.onChange([self _textInputMetrics]);
+  }
+}
+
+- (void)textInputDidChangeSelection
+{
+  if (_comingFromJS) {
+    return;
+  }
+
+  // T207198334: Setting a new AttributedString (_comingFromJS) will trigger a selection change before the backing
+  // string is updated, so indicies won't point to what we want yet. Only respond to user selection change, and let
+  // `_setAttributedString` handle updating typing attributes if content changes.
+  [self _updateTypingAttributes];
+
+  const auto &props = static_cast<const TextInputProps &>(*_props);
+  if (props.multiline && ![_lastStringStateWasUpdatedWith isEqual:_backedTextInputView.attributedText]) {
+    [self textInputDidChange];
+    _ignoreNextTextInputCall = YES;
+  }
+
+  if (_eventEmitter) {
+    static_cast<const TextInputEventEmitter &>(*_eventEmitter).onSelectionChange([self _textInputMetrics]);
+  }
+}
+
+#pragma mark - RCTBackedTextInputDelegate (UIScrollViewDelegate)
+
+- (void)scrollViewDidScroll:(UIScrollView *)scrollView
+{
+  if (_eventEmitter) {
+    static_cast<const TextInputEventEmitter &>(*_eventEmitter).onScroll([self _textInputMetrics]);
+  }
+}
+
+#pragma mark - Native Commands
+
+- (void)handleCommand:(const NSString *)commandName args:(const NSArray *)args
+{
+  RCTTextInputHandleCommand(self, commandName, args);
+}
+
+- (void)focus
+{
+  [_backedTextInputView becomeFirstResponder];
+
+  const auto &props = static_cast<const TextInputProps &>(*_props);
+
+  if (props.traits.clearTextOnFocus) {
+    _backedTextInputView.attributedText = nil;
+    [self textInputDidChange];
+  }
+
+  if (props.traits.selectTextOnFocus) {
+    [_backedTextInputView selectAll:nil];
+    [self textInputDidChangeSelection];
+  }
+
+  [self scrollCursorIntoView];
+}
+
+- (void)blur
+{
+  [_backedTextInputView resignFirstResponder];
+}
+
+- (void)setTextAndSelection:(NSInteger)eventCount
+                      value:(NSString *__nullable)value
+                      start:(NSInteger)start
+                        end:(NSInteger)end
+{
+  if (_mostRecentEventCount != eventCount) {
+    return;
+  }
+  _comingFromJS = YES;
+  if (value && ![value isEqualToString:_backedTextInputView.attributedText.string]) {
+    NSAttributedString *attributedString =
+        [[NSAttributedString alloc] initWithString:value attributes:_backedTextInputView.defaultTextAttributes];
+    [self _setAttributedString:attributedString];
+    [self _updateState];
+  }
+
+  UITextPosition *startPosition = [_backedTextInputView positionFromPosition:_backedTextInputView.beginningOfDocument
+                                                                      offset:start];
+  UITextPosition *endPosition = [_backedTextInputView positionFromPosition:_backedTextInputView.beginningOfDocument
+                                                                    offset:end];
+
+  if (startPosition && endPosition) {
+    UITextRange *range = [_backedTextInputView textRangeFromPosition:startPosition toPosition:endPosition];
+    [_backedTextInputView setSelectedTextRange:range notifyDelegate:NO];
+    // ensure we scroll to the selected position
+    NSInteger offsetEnd = [_backedTextInputView offsetFromPosition:_backedTextInputView.beginningOfDocument
+                                                        toPosition:range.end];
+    [_backedTextInputView scrollRangeToVisible:NSMakeRange(offsetEnd, 0)];
+  }
+  _comingFromJS = NO;
+}
+
+#pragma mark - Default input accessory view
+
+- (NSString *)returnKeyTypeToString:(UIReturnKeyType)returnKeyType
+{
+  switch (returnKeyType) {
+    case UIReturnKeyGo:
+      return @"Go";
+    case UIReturnKeyNext:
+      return @"Next";
+    case UIReturnKeySearch:
+      return @"Search";
+    case UIReturnKeySend:
+      return @"Send";
+    case UIReturnKeyYahoo:
+      return @"Yahoo";
+    case UIReturnKeyGoogle:
+      return @"Google";
+    case UIReturnKeyRoute:
+      return @"Route";
+    case UIReturnKeyJoin:
+      return @"Join";
+    case UIReturnKeyEmergencyCall:
+      return @"Emergency Call";
+    default:
+      return @"Done";
+  }
+}
+
+- (void)initializeReturnKeyType
+{
+  returnKeyTypesSet = [NSSet setWithObjects:@(UIReturnKeyDone),
+                                            @(UIReturnKeyGo),
+                                            @(UIReturnKeyNext),
+                                            @(UIReturnKeySearch),
+                                            @(UIReturnKeySend),
+                                            @(UIReturnKeyYahoo),
+                                            @(UIReturnKeyGoogle),
+                                            @(UIReturnKeyRoute),
+                                            @(UIReturnKeyJoin),
+                                            @(UIReturnKeyRoute),
+                                            @(UIReturnKeyEmergencyCall),
+                                            nil];
+}
+
+- (void)setDefaultInputAccessoryView
+{
+  // InputAccessoryView component sets the inputAccessoryView when inputAccessoryViewID exists
+  if (_backedTextInputView.inputAccessoryViewID) {
+    if (_backedTextInputView.isFirstResponder) {
+      [_backedTextInputView reloadInputViews];
+    }
+    return;
+  }
+
+  UIKeyboardType keyboardType = _backedTextInputView.keyboardType;
+  UIReturnKeyType returnKeyType = _backedTextInputView.returnKeyType;
+  NSString *inputAccessoryViewButtonLabel = _backedTextInputView.inputAccessoryViewButtonLabel;
+
+  BOOL containsKeyType = [returnKeyTypesSet containsObject:@(returnKeyType)];
+  BOOL containsInputAccessoryViewButtonLabel = inputAccessoryViewButtonLabel != nil;
+
+  // These keyboard types (all are number pads) don't have a "returnKey" button by default,
+  // so we create an `inputAccessoryView` with this button for them.
+  BOOL shouldHaveInputAccessoryView =
+      (keyboardType == UIKeyboardTypeNumberPad || keyboardType == UIKeyboardTypePhonePad ||
+       keyboardType == UIKeyboardTypeDecimalPad || keyboardType == UIKeyboardTypeASCIICapableNumberPad) &&
+      (containsKeyType || containsInputAccessoryViewButtonLabel);
+
+  if (_hasInputAccessoryView == shouldHaveInputAccessoryView) {
+    return;
+  }
+
+  _hasInputAccessoryView = shouldHaveInputAccessoryView;
+
+  if (shouldHaveInputAccessoryView) {
+    NSString *buttonLabel = inputAccessoryViewButtonLabel != nil ? inputAccessoryViewButtonLabel
+                                                                 : [self returnKeyTypeToString:returnKeyType];
+
+    UIToolbar *toolbarView = [UIToolbar new];
+    [toolbarView sizeToFit];
+    UIBarButtonItem *flexibleSpace =
+        [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFlexibleSpace target:nil action:nil];
+    UIBarButtonItem *doneButton = [[UIBarButtonItem alloc] initWithTitle:buttonLabel
+                                                                   style:UIBarButtonItemStylePlain
+                                                                  target:self
+                                                                  action:@selector(handleInputAccessoryDoneButton)];
+    toolbarView.items = @[ flexibleSpace, doneButton ];
+    _backedTextInputView.inputAccessoryView = toolbarView;
+  } else {
+    _backedTextInputView.inputAccessoryView = nil;
+  }
+
+  if (_backedTextInputView.isFirstResponder) {
+    [_backedTextInputView reloadInputViews];
+  }
+}
+
+- (void)handleInputAccessoryDoneButton
+{
+  // Ignore the value of whether we submitted; just make sure the submit event is called if necessary.
+  [self textInputShouldSubmitOnReturn];
+  if ([self textInputShouldReturn]) {
+    [_backedTextInputView endEditing:YES];
+  }
+}
+
+#pragma mark - Other
+
+- (TextInputEventEmitter::Metrics)_textInputMetrics
+{
+  return {
+      .text = RCTStringFromNSString(_backedTextInputView.attributedText.string),
+      .selectionRange = [self _selectionRange],
+      .eventCount = static_cast<int>(_mostRecentEventCount),
+      .contentOffset = RCTPointFromCGPoint(_backedTextInputView.contentOffset),
+      .contentInset = RCTEdgeInsetsFromUIEdgeInsets(_backedTextInputView.contentInset),
+      .contentSize = RCTSizeFromCGSize(_backedTextInputView.contentSize),
+      .layoutMeasurement = RCTSizeFromCGSize(_backedTextInputView.bounds.size),
+      .zoomScale = _backedTextInputView.zoomScale,
+  };
+}
+
+- (void)_updateState
+{
+  if (!_state) {
+    return;
+  }
+  NSAttributedString *attributedString = _backedTextInputView.attributedText;
+  auto data = _state->getData();
+  _lastStringStateWasUpdatedWith = attributedString;
+  data.attributedStringBox = RCTAttributedStringBoxFromNSAttributedString(attributedString);
+  _mostRecentEventCount += _comingFromJS ? 0 : 1;
+  data.mostRecentEventCount = _mostRecentEventCount;
+  _state->updateState(std::move(data));
+}
+
+- (AttributedString::Range)_selectionRange
+{
+  UITextRange *selectedTextRange = _backedTextInputView.selectedTextRange;
+  NSInteger start = [_backedTextInputView offsetFromPosition:_backedTextInputView.beginningOfDocument
+                                                  toPosition:selectedTextRange.start];
+  NSInteger end = [_backedTextInputView offsetFromPosition:_backedTextInputView.beginningOfDocument
+                                                toPosition:selectedTextRange.end];
+  return AttributedString::Range{(int)start, (int)(end - start)};
+}
+
+- (void)_restoreTextSelection
+{
+  [self _restoreTextSelectionAndIgnoreCaretChange:NO];
+}
+
+- (void)_restoreTextSelectionAndIgnoreCaretChange:(BOOL)ignore
+{
+  const auto &selection = static_cast<const TextInputProps &>(*_props).selection;
+  if (!selection.has_value()) {
+    return;
+  }
+  auto start = [_backedTextInputView positionFromPosition:_backedTextInputView.beginningOfDocument
+                                                   offset:selection->start];
+  auto end = [_backedTextInputView positionFromPosition:_backedTextInputView.beginningOfDocument offset:selection->end];
+  auto range = [_backedTextInputView textRangeFromPosition:start toPosition:end];
+  if (ignore && range.empty) {
+    return;
+  }
+  [_backedTextInputView setSelectedTextRange:range notifyDelegate:YES];
+}
+
+- (void)_setAttributedString:(NSAttributedString *)attributedString
+{
+  if ([self _textOf:attributedString equals:_backedTextInputView.attributedText]) {
+    return;
+  }
+  UITextRange *selectedRange = _backedTextInputView.selectedTextRange;
+  NSInteger oldTextLength = _backedTextInputView.attributedText.string.length;
+  _backedTextInputView.attributedText = attributedString;
+  // Updating the UITextView attributedText, for example changing the lineHeight, the color or adding
+  // a new paragraph with \n, causes the cursor to move to the end of the Text and scroll.
+  // This is fixed by restoring the cursor position and scrolling to that position (iOS issue 652653).
+  // Maintaining a cursor position relative to the end of the old text.
+  NSInteger offsetStart = [_backedTextInputView offsetFromPosition:_backedTextInputView.beginningOfDocument
+                                                        toPosition:selectedRange.start];
+  NSInteger offsetFromEnd = oldTextLength - offsetStart;
+  NSInteger newOffset = attributedString.string.length - offsetFromEnd;
+  UITextPosition *position = [_backedTextInputView positionFromPosition:_backedTextInputView.beginningOfDocument
+                                                                 offset:newOffset];
+  [_backedTextInputView setSelectedTextRange:[_backedTextInputView textRangeFromPosition:position toPosition:position]
+                              notifyDelegate:YES];
+  [_backedTextInputView scrollRangeToVisible:NSMakeRange(offsetStart, 0)];
+
+  // A zero-length selection range can cause the caret position to change on iOS,
+  // and we have already updated the caret position, so we can safely ignore caret changing in this place.
+  [self _restoreTextSelectionAndIgnoreCaretChange:YES];
+  [self _updateTypingAttributes];
+  _lastStringStateWasUpdatedWith = attributedString;
+}
+
+// Ensure that newly typed text will inherit any custom attributes. We follow the logic of RN Android, where attributes
+// to the left of the cursor are copied into new text, unless we are at the start of the field, in which case we will
+// copy the attributes from text to the right. This allows consistency between backed input and new AttributedText
+// https://github.com/facebook/react-native/blob/3102a58df38d96f3dacef0530e4dbb399037fcd2/packages/react-native/ReactAndroid/src/main/java/com/facebook/react/views/text/internal/span/SetSpanOperation.kt#L30
+- (void)_updateTypingAttributes
+{
+  if (_backedTextInputView.attributedText.length > 0 && _backedTextInputView.selectedTextRange != nil) {
+    NSUInteger offsetStart = [_backedTextInputView offsetFromPosition:_backedTextInputView.beginningOfDocument
+                                                           toPosition:_backedTextInputView.selectedTextRange.start];
+
+    NSUInteger samplePoint = offsetStart == 0 ? 0 : offsetStart - 1;
+    _backedTextInputView.typingAttributes = [_backedTextInputView.attributedText attributesAtIndex:samplePoint
+                                                                                    effectiveRange:NULL];
+  }
+}
+
+- (void)scrollCursorIntoView
+{
+  UITextRange *selectedRange = _backedTextInputView.selectedTextRange;
+  if (selectedRange.empty) {
+    NSInteger offsetStart = [_backedTextInputView offsetFromPosition:_backedTextInputView.beginningOfDocument
+                                                          toPosition:selectedRange.start];
+    [_backedTextInputView scrollRangeToVisible:NSMakeRange(offsetStart, 0)];
+  }
+}
+
+- (void)_setMultiline:(BOOL)multiline
+{
+  [_backedTextInputView removeFromSuperview];
+  UIView<RCTBackedTextInputViewProtocol> *backedTextInputView = multiline ? [RCTUITextView new] : [RCTUITextField new];
+  backedTextInputView.frame = _backedTextInputView.frame;
+  RCTCopyBackedTextInput(_backedTextInputView, backedTextInputView);
+  _backedTextInputView = backedTextInputView;
+  [self addSubview:_backedTextInputView];
+}
+
+- (void)_setShowSoftInputOnFocus:(BOOL)showSoftInputOnFocus
+{
+  if (showSoftInputOnFocus) {
+    // Resets to default keyboard.
+    _backedTextInputView.inputView = nil;
+
+    // Without the call to reloadInputViews, the keyboard will not change until the textInput field (the first
+    // responder) loses and regains focus.
+    if (_backedTextInputView.isFirstResponder) {
+      [_backedTextInputView reloadInputViews];
+    }
+  } else {
+    // Hides keyboard, but keeps blinking cursor.
+    _backedTextInputView.inputView = [UIView new];
+  }
+}
+
+- (BOOL)_textOf:(NSAttributedString *)newText equals:(NSAttributedString *)oldText
+{
+  // When the dictation is running we can't update the attributed text on the backed up text view
+  // because setting the attributed string will kill the dictation. This means that we can't impose
+  // the settings on a dictation.
+  // Similarly, when the user is in the middle of inputting some text in Japanese/Chinese, there will be styling on the
+  // text that we should disregard. See
+  // https://developer.apple.com/documentation/uikit/uitextinput/1614489-markedtextrange?language=objc for more info.
+  // Also, updating the attributed text while inputting Korean language will break input mechanism.
+  // If the user added an emoji, the system adds a font attribute for the emoji and stores the original font in
+  // NSOriginalFont. Lastly, when entering a password, etc., there will be additional styling on the field as the native
+  // text view handles showing the last character for a split second.
+  __block BOOL fontHasBeenUpdatedBySystem = false;
+  [oldText enumerateAttribute:@"NSOriginalFont"
+                      inRange:NSMakeRange(0, oldText.length)
+                      options:0
+                   usingBlock:^(id value, NSRange range, BOOL *stop) {
+                     if (value) {
+                       fontHasBeenUpdatedBySystem = true;
+                     }
+                   }];
+
+  BOOL shouldFallbackToBareTextComparison =
+      [_backedTextInputView.textInputMode.primaryLanguage isEqualToString:@"dictation"] ||
+      [_backedTextInputView.textInputMode.primaryLanguage isEqualToString:@"ko-KR"] ||
+      _backedTextInputView.markedTextRange || _backedTextInputView.isSecureTextEntry || fontHasBeenUpdatedBySystem;
+
+  if (shouldFallbackToBareTextComparison) {
+    return [newText.string isEqualToString:oldText.string];
+  } else {
+    return RCTIsAttributedStringEffectivelySame(
+        newText, oldText, _originalTypingAttributes, static_cast<const TextInputProps &>(*_props).textAttributes);
+  }
+}
+
+- (SubmitBehavior)getSubmitBehavior
+{
+  const auto &props = static_cast<const TextInputProps &>(*_props);
+  return props.getNonDefaultSubmitBehavior();
+}
+
+@end
+
+Class<RCTComponentViewProtocol> RCTTextInputCls(void)
+{
+  return RCTTextInputComponentView.class;
+}
diff --git a/node_modules/react-native/React/Fabric/Mounting/ComponentViews/View/RCTViewComponentView.mm b/node_modules/react-native/React/Fabric/Mounting/ComponentViews/View/RCTViewComponentView.mm
index a99f103..894e200 100644
--- a/node_modules/react-native/React/Fabric/Mounting/ComponentViews/View/RCTViewComponentView.mm
+++ b/node_modules/react-native/React/Fabric/Mounting/ComponentViews/View/RCTViewComponentView.mm
@@ -612,6 +612,8 @@ - (void)prepareForRecycle
     self.layer.opacity = (float)props.opacity;
   }
 
+  self.autoresizingMask = UIViewAutoresizingNone;
+
   _propKeysManagedByAnimated_DO_NOT_USE_THIS_IS_BROKEN = nil;
   _eventEmitter.reset();
   _isJSResponder = NO;
diff --git a/node_modules/react-native/React/Views/RCTModalHostViewManager.m b/node_modules/react-native/React/Views/RCTModalHostViewManager.m
index 203d0b4..2e05e9c 100644
--- a/node_modules/react-native/React/Views/RCTModalHostViewManager.m
+++ b/node_modules/react-native/React/Views/RCTModalHostViewManager.m
@@ -64,6 +64,13 @@ - (void)presentModalHostView:(RCTModalHostView *)modalHostView
     if (self->_presentationBlock) {
       self->_presentationBlock([modalHostView reactViewController], viewController, animated, completionBlock);
     } else {
+      // In our App, If an input is blurred and a modal is opened, the rootView will become the firstResponder, which
+      // will cause system to retain a wrong keyboard state, and then the keyboard to flicker when the modal is closed.
+      // We first resign the rootView to avoid this problem.
+      UIWindow *window = RCTKeyWindow();
+      if (window && window.rootViewController && [window.rootViewController.view isFirstResponder]) {
+        [window.rootViewController.view resignFirstResponder];
+      }
       [[modalHostView reactViewController] presentViewController:viewController
                                                         animated:animated
                                                       completion:completionBlock];
diff --git a/node_modules/react-native/ReactAndroid/src/main/java/com/facebook/react/modules/dialog/AlertFragment.kt b/node_modules/react-native/ReactAndroid/src/main/java/com/facebook/react/modules/dialog/AlertFragment.kt
index 2f1b12b..bce209e 100644
--- a/node_modules/react-native/ReactAndroid/src/main/java/com/facebook/react/modules/dialog/AlertFragment.kt
+++ b/node_modules/react-native/ReactAndroid/src/main/java/com/facebook/react/modules/dialog/AlertFragment.kt
@@ -9,6 +9,7 @@ package com.facebook.react.modules.dialog
 
 import android.annotation.SuppressLint
 import android.app.Dialog
+import android.app.AlertDialog
 import android.content.Context
 import android.content.DialogInterface
 import android.os.Build
@@ -16,7 +17,6 @@ import android.os.Bundle
 import android.view.LayoutInflater
 import android.view.View
 import android.widget.TextView
-import androidx.appcompat.app.AlertDialog
 import androidx.core.view.AccessibilityDelegateCompat
 import androidx.core.view.ViewCompat
 import androidx.core.view.accessibility.AccessibilityNodeInfoCompat
diff --git a/node_modules/react-native/ReactAndroid/src/main/java/com/facebook/react/views/scroll/ReactScrollViewHelper.kt b/node_modules/react-native/ReactAndroid/src/main/java/com/facebook/react/views/scroll/ReactScrollViewHelper.kt
index 55e4d53..bd4ad5c 100644
--- a/node_modules/react-native/ReactAndroid/src/main/java/com/facebook/react/views/scroll/ReactScrollViewHelper.kt
+++ b/node_modules/react-native/ReactAndroid/src/main/java/com/facebook/react/views/scroll/ReactScrollViewHelper.kt
@@ -564,7 +564,7 @@ public object ReactScrollViewHelper {
     /** Get the padding on the top for nav bar */
     public var scrollAwayPaddingTop: Int = 0
     /** Get the Fabric state of last scroll position */
-    public val lastStateUpdateScroll: Point = Point(-1, -1)
+    public val lastStateUpdateScroll: Point = Point(0, 0)
     /** Get true if the previous animation was canceled */
     public var isCanceled: Boolean = false
     /** Get true if previous animation was finished */
diff --git a/node_modules/react-native/ReactCommon/react/renderer/textlayoutmanager/platform/ios/react/renderer/textlayoutmanager/RCTFontUtils.mm b/node_modules/react-native/ReactCommon/react/renderer/textlayoutmanager/platform/ios/react/renderer/textlayoutmanager/RCTFontUtils.mm
index 39093ef..36cb558 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/textlayoutmanager/platform/ios/react/renderer/textlayoutmanager/RCTFontUtils.mm
+++ b/node_modules/react-native/ReactCommon/react/renderer/textlayoutmanager/platform/ios/react/renderer/textlayoutmanager/RCTFontUtils.mm
@@ -38,9 +38,6 @@ static RCTFontProperties RCTResolveFontProperties(
 {
   fontProperties.family = fontProperties.family.length ? fontProperties.family : baseFontProperties.family;
   fontProperties.size = !isnan(fontProperties.size) ? fontProperties.size : baseFontProperties.size;
-  fontProperties.weight = !isnan(fontProperties.weight) ? fontProperties.weight : baseFontProperties.weight;
-  fontProperties.style =
-      fontProperties.style != RCTFontStyleUndefined ? fontProperties.style : baseFontProperties.style;
   fontProperties.variant =
       fontProperties.variant != RCTFontVariantUndefined ? fontProperties.variant : baseFontProperties.variant;
   return fontProperties;
@@ -319,10 +316,14 @@ static UIFontDescriptorSystemDesign RCTGetFontDescriptorSystemDesign(NSString *f
   } else if ([fontProperties.family isEqualToString:defaultFontProperties.family]) {
     // Handle system font as special case. This ensures that we preserve
     // the specific metrics of the standard system font as closely as possible.
+    fontProperties.weight = !isnan(fontProperties.weight) ? fontProperties.weight : defaultFontProperties.weight;
+    fontProperties.style =
+        fontProperties.style != RCTFontStyleUndefined ? fontProperties.style : defaultFontProperties.style;
     font = RCTDefaultFontWithFontProperties(fontProperties);
   } else {
     NSArray<NSString *> *fontNames = [UIFont fontNamesForFamilyName:fontProperties.family];
     UIFontWeight fontWeight = fontProperties.weight;
+    RCTFontStyle fontStyle = fontProperties.style;
 
     if (fontNames.count == 0) {
       // Gracefully handle being given a font name rather than font family, for
@@ -335,15 +336,18 @@ static UIFontDescriptorSystemDesign RCTGetFontDescriptorSystemDesign(NSString *f
         // Failback to system font.
         font = [UIFont systemFontOfSize:effectiveFontSize weight:fontProperties.weight];
       }
+      fontNames = [UIFont fontNamesForFamilyName:font.familyName];
+      fontWeight = isnan(fontWeight) ? RCTGetFontWeight(font) : fontWeight;
+      fontStyle = fontStyle == RCTFontStyleUndefined ? RCTGetFontStyle(font) : fontStyle;
     }
 
-    if (fontNames.count > 0) {
+    if (fontNames.count != 0) {
       // Get the closest font that matches the given weight for the fontFamily
       CGFloat closestWeight = INFINITY;
       for (NSString *name in fontNames) {
         UIFont *fontMatch = [UIFont fontWithName:name size:effectiveFontSize];
 
-        if (RCTGetFontStyle(fontMatch) != fontProperties.style) {
+        if (RCTGetFontStyle(fontMatch) != fontStyle) {
           continue;
         }
 
